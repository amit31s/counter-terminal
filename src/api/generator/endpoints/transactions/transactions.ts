/**
 * Generated by orval v6.11.0 🍺
 * Do not edit manually.
 * transactions
 * PO Transactions
 * OpenAPI spec version: 0.3.0
 */
import {
  useQuery,
  useMutation
} from 'react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
import type {
  BasketCreateResponse,
  ErrorResp,
  NewBasket,
  BasketClosed,
  BasketWithEntries,
  EntryResponse,
  EntryCore,
  Entry,
  LastseqnumberResponse,
  Fulfilment,
  UpdateBasketEntryFulfilmentBodyTwo,
  Reversal
} from '../../model'
import { useCustomInstance } from '../../mutator/useCustomInstance';
import type { ErrorType } from '../../mutator/useCustomInstance';


/**
 * This endpoint is used to Create Unique basket
 * @summary This endpoint is used to Create Unique basket
 */
export const useCreateBasketHook = () => {
        const createBasket = useCustomInstance<BasketCreateResponse>();

        return (
    newBasket: NewBasket,
 ) => {
        return createBasket(
          {url: `/basket`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: newBasket
    },
          );
        }
      }
    


    export type CreateBasketMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCreateBasketHook>>>>
    export type CreateBasketMutationBody = NewBasket
    export type CreateBasketMutationError = ErrorType<ErrorResp | void>

    export const useCreateBasket = <TError = ErrorType<ErrorResp | void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateBasketHook>>>, TError,{data: NewBasket}, TContext>, }
) => {
      const {mutation: mutationOptions} = options ?? {};

      const createBasket =  useCreateBasketHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useCreateBasketHook>>>, {data: NewBasket}> = (props) => {
          const {data} = props ?? {};

          return  createBasket(data,)
        }

        

      return useMutation<Awaited<ReturnType<typeof createBasket>>, TError, {data: NewBasket}, TContext>(mutationFn, mutationOptions);
    }
    /**
 * This endpoint method is used to close basket or modify basket.
 * @summary This endpoint is used to close basket or modify basket
 */
export const useCloseOrModifyBasketHook = () => {
        const closeOrModifyBasket = useCustomInstance<void>();

        return (
    basketClosed: BasketClosed,
 ) => {
        return closeOrModifyBasket(
          {url: `/basket`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: basketClosed
    },
          );
        }
      }
    


    export type CloseOrModifyBasketMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCloseOrModifyBasketHook>>>>
    export type CloseOrModifyBasketMutationBody = BasketClosed
    export type CloseOrModifyBasketMutationError = ErrorType<ErrorResp>

    export const useCloseOrModifyBasket = <TError = ErrorType<ErrorResp>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCloseOrModifyBasketHook>>>, TError,{data: BasketClosed}, TContext>, }
) => {
      const {mutation: mutationOptions} = options ?? {};

      const closeOrModifyBasket =  useCloseOrModifyBasketHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useCloseOrModifyBasketHook>>>, {data: BasketClosed}> = (props) => {
          const {data} = props ?? {};

          return  closeOrModifyBasket(data,)
        }

        

      return useMutation<Awaited<ReturnType<typeof closeOrModifyBasket>>, TError, {data: BasketClosed}, TContext>(mutationFn, mutationOptions);
    }
    /**
 * Get basket.
 * @summary This endpoint is used to get Basket
 */
export const useGetBasketHook = () => {
        const getBasket = useCustomInstance<BasketWithEntries>();

        return (
    basketId: string,
 signal?: AbortSignal
) => {
        return getBasket(
          {url: `/basket/${basketId}`, method: 'get', signal
    },
          );
        }
      }
    

export const getGetBasketQueryKey = (basketId: string,) => [`/basket/${basketId}`];

    
export type GetBasketQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetBasketHook>>>>
export type GetBasketQueryError = ErrorType<void>

export const useGetBasket = <TData = Awaited<ReturnType<ReturnType<typeof useGetBasketHook>>>, TError = ErrorType<void>>(
 basketId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetBasketHook>>>, TError, TData>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasketQueryKey(basketId);

  const getBasket =  useGetBasketHook();


  const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetBasketHook>>>> = ({ signal }) => getBasket(basketId, signal);


  

  const query = useQuery<Awaited<ReturnType<ReturnType<typeof useGetBasketHook>>>, TError, TData>(queryKey, queryFn, {enabled: !!(basketId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

/**
 * This endpoint is used to create basket entry
 * @summary This endpoint is used to create basket entry
 */
export const useCreateBasketEntryHook = () => {
        const createBasketEntry = useCustomInstance<EntryResponse>();

        return (
    basketId: string,
    entryCore: EntryCore,
 ) => {
        return createBasketEntry(
          {url: `/basket/${basketId}/entry`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: entryCore
    },
          );
        }
      }
    


    export type CreateBasketEntryMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCreateBasketEntryHook>>>>
    export type CreateBasketEntryMutationBody = EntryCore
    export type CreateBasketEntryMutationError = ErrorType<ErrorResp | void>

    export const useCreateBasketEntry = <TError = ErrorType<ErrorResp | void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateBasketEntryHook>>>, TError,{basketId: string;data: EntryCore}, TContext>, }
) => {
      const {mutation: mutationOptions} = options ?? {};

      const createBasketEntry =  useCreateBasketEntryHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useCreateBasketEntryHook>>>, {basketId: string;data: EntryCore}> = (props) => {
          const {basketId,data} = props ?? {};

          return  createBasketEntry(basketId,data,)
        }

        

      return useMutation<Awaited<ReturnType<typeof createBasketEntry>>, TError, {basketId: string;data: EntryCore}, TContext>(mutationFn, mutationOptions);
    }
    /**
 * This endpoint method is used to get basket entry
 * @summary This endpoint is used to get basket entry
 */
export const useGetBasketEntryHook = () => {
        const getBasketEntry = useCustomInstance<Entry>();

        return (
    basketId: string,
    entry: string,
 signal?: AbortSignal
) => {
        return getBasketEntry(
          {url: `/basket/${basketId}/entry/${entry}`, method: 'get', signal
    },
          );
        }
      }
    

export const getGetBasketEntryQueryKey = (basketId: string,
    entry: string,) => [`/basket/${basketId}/entry/${entry}`];

    
export type GetBasketEntryQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryHook>>>>
export type GetBasketEntryQueryError = ErrorType<void>

export const useGetBasketEntry = <TData = Awaited<ReturnType<ReturnType<typeof useGetBasketEntryHook>>>, TError = ErrorType<void>>(
 basketId: string,
    entry: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryHook>>>, TError, TData>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasketEntryQueryKey(basketId,entry);

  const getBasketEntry =  useGetBasketEntryHook();


  const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryHook>>>> = ({ signal }) => getBasketEntry(basketId,entry, signal);


  

  const query = useQuery<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryHook>>>, TError, TData>(queryKey, queryFn, {enabled: !!(basketId && entry), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

/**
 * This endpoint is used to get the last sequence number used in baskedID for given branchId and nodeID. This api is rquired when device  is started /restarted to get last sequence number used so it can increment and use it creating new basket.
 * @summary This endpoint is used to get the last sequence number used in baskedID for given branchId and nodeID. This api is rquired when device  is started /restarted to get last sequence number used so it can increment and use it creating new basket.
 */
export const useGetLastSeqNumberHook = () => {
        const getLastSeqNumber = useCustomInstance<LastseqnumberResponse>();

        return (
    branchID: string,
    nodeID: number,
 signal?: AbortSignal
) => {
        return getLastSeqNumber(
          {url: `/branch/${branchID}/node/${nodeID}/lastSeqNumber`, method: 'get', signal
    },
          );
        }
      }
    

export const getGetLastSeqNumberQueryKey = (branchID: string,
    nodeID: number,) => [`/branch/${branchID}/node/${nodeID}/lastSeqNumber`];

    
export type GetLastSeqNumberQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetLastSeqNumberHook>>>>
export type GetLastSeqNumberQueryError = ErrorType<unknown>

export const useGetLastSeqNumber = <TData = Awaited<ReturnType<ReturnType<typeof useGetLastSeqNumberHook>>>, TError = ErrorType<unknown>>(
 branchID: string,
    nodeID: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetLastSeqNumberHook>>>, TError, TData>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLastSeqNumberQueryKey(branchID,nodeID);

  const getLastSeqNumber =  useGetLastSeqNumberHook();


  const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetLastSeqNumberHook>>>> = ({ signal }) => getLastSeqNumber(branchID,nodeID, signal);


  

  const query = useQuery<Awaited<ReturnType<ReturnType<typeof useGetLastSeqNumberHook>>>, TError, TData>(queryKey, queryFn, {enabled: !!(branchID && nodeID), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

/**
 * This endpoint is used to post fulfilment of an entry
 */
export const useUpdateBasketEntryFulfilmentHook = () => {
        const updateBasketEntryFulfilment = useCustomInstance<void>();

        return (
    basketId: string,
    entry: string,
    updateBasketEntryFulfilmentBody: Fulfilment | UpdateBasketEntryFulfilmentBodyTwo,
 ) => {
        return updateBasketEntryFulfilment(
          {url: `/basket/${basketId}/entry/${entry}/fulfilment`, method: 'post',
      data: updateBasketEntryFulfilmentBody
    },
          );
        }
      }
    


    export type UpdateBasketEntryFulfilmentMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useUpdateBasketEntryFulfilmentHook>>>>
    export type UpdateBasketEntryFulfilmentMutationBody = Fulfilment | UpdateBasketEntryFulfilmentBodyTwo
    export type UpdateBasketEntryFulfilmentMutationError = ErrorType<ErrorResp>

    export const useUpdateBasketEntryFulfilment = <TError = ErrorType<ErrorResp>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateBasketEntryFulfilmentHook>>>, TError,{basketId: string;entry: string;data: Fulfilment | UpdateBasketEntryFulfilmentBodyTwo}, TContext>, }
) => {
      const {mutation: mutationOptions} = options ?? {};

      const updateBasketEntryFulfilment =  useUpdateBasketEntryFulfilmentHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useUpdateBasketEntryFulfilmentHook>>>, {basketId: string;entry: string;data: Fulfilment | UpdateBasketEntryFulfilmentBodyTwo}> = (props) => {
          const {basketId,entry,data} = props ?? {};

          return  updateBasketEntryFulfilment(basketId,entry,data,)
        }

        

      return useMutation<Awaited<ReturnType<typeof updateBasketEntryFulfilment>>, TError, {basketId: string;entry: string;data: Fulfilment | UpdateBasketEntryFulfilmentBodyTwo}, TContext>(mutationFn, mutationOptions);
    }
    /**
 * This endpoint is used to get reversal status of an entry
 */
export const useGetBasketEntryReversalHook = () => {
        const getBasketEntryReversal = useCustomInstance<Reversal>();

        return (
    transactionId: string,
 signal?: AbortSignal
) => {
        return getBasketEntryReversal(
          {url: `/transaction/${transactionId}/reversal`, method: 'get', signal
    },
          );
        }
      }
    

export const getGetBasketEntryReversalQueryKey = (transactionId: string,) => [`/transaction/${transactionId}/reversal`];

    
export type GetBasketEntryReversalQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryReversalHook>>>>
export type GetBasketEntryReversalQueryError = ErrorType<void | ErrorResp>

export const useGetBasketEntryReversal = <TData = Awaited<ReturnType<ReturnType<typeof useGetBasketEntryReversalHook>>>, TError = ErrorType<void | ErrorResp>>(
 transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryReversalHook>>>, TError, TData>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBasketEntryReversalQueryKey(transactionId);

  const getBasketEntryReversal =  useGetBasketEntryReversalHook();


  const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryReversalHook>>>> = ({ signal }) => getBasketEntryReversal(transactionId, signal);


  

  const query = useQuery<Awaited<ReturnType<ReturnType<typeof useGetBasketEntryReversalHook>>>, TError, TData>(queryKey, queryFn, {enabled: !!(transactionId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

/**
 * This endpoint is used to get last basket
 */
export const useGetLastBasketHook = () => {
        const getLastBasket = useCustomInstance<BasketWithEntries>();

        return (
    branchID: string,
    nodeID: number,
 signal?: AbortSignal
) => {
        return getLastBasket(
          {url: `/branch/${branchID}/node/${nodeID}/lastBasket`, method: 'get', signal
    },
          );
        }
      }
    

export const getGetLastBasketQueryKey = (branchID: string,
    nodeID: number,) => [`/branch/${branchID}/node/${nodeID}/lastBasket`];

    
export type GetLastBasketQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetLastBasketHook>>>>
export type GetLastBasketQueryError = ErrorType<unknown>

export const useGetLastBasket = <TData = Awaited<ReturnType<ReturnType<typeof useGetLastBasketHook>>>, TError = ErrorType<unknown>>(
 branchID: string,
    nodeID: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetLastBasketHook>>>, TError, TData>, }

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLastBasketQueryKey(branchID,nodeID);

  const getLastBasket =  useGetLastBasketHook();


  const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetLastBasketHook>>>> = ({ signal }) => getLastBasket(branchID,nodeID, signal);


  

  const query = useQuery<Awaited<ReturnType<ReturnType<typeof useGetLastBasketHook>>>, TError, TData>(queryKey, queryFn, {enabled: !!(branchID && nodeID), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}

